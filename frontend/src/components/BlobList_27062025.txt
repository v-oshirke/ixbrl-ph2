import React, { useEffect, useState } from 'react';
import { Button, Card, CardContent, Typography, Box, List, ListItem, ListItemText, Link, Checkbox, TextField, Grid, Alert, Stack } from '@mui/material';
import dayjs from 'dayjs';

const CONTAINER_NAMES = ['silver', 'gold'];

const CONTAINER_LABELS: Record<string, string> = {
  silver: 'Input',
  gold: 'Output',
};

const functionUrl = `/api/app_getBlobsByContainer`;

interface BlobItem {
  name: string;
  url: string;
}

export interface SelectedBlob extends BlobItem {
  container: string;
}

interface BlobListProps {
  onSelectionChange?: (selected: SelectedBlob[]) => void;
}

const BlobList: React.FC<BlobListProps> = ({ onSelectionChange }) => {
  const [blobsByContainer, setBlobsByContainer] = useState<Record<string, BlobItem[]>>({ silver: [], gold: [] });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedBlobs, setSelectedBlobs] = useState<SelectedBlob[]>([]);

  const [endDate, setEndDate] = useState('');
  const [durationStart, setDurationStart] = useState('');
  const [durationEnd, setDurationEnd] = useState('');
  const [priorEndDate, setPriorEndDate] = useState('');
  const [priorDurationStart, setPriorDurationStart] = useState('');
  const [priorDurationEnd, setPriorDurationEnd] = useState('');
  const [openingDate, setOpeningDate] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [dateFieldsDisabled, setDateFieldsDisabled] = useState(true);

  const fetchBlobsFromAllContainers = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(functionUrl);
      if (!response.ok) throw new Error(`Error: ${response.status} - ${response.statusText}`);
      const data: Record<string, BlobItem[]> = await response.json();
      setBlobsByContainer(data);
      resetDates();
    } catch (err: unknown) {
      if (err instanceof Error) setError(`Error: ${err.message || 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const resetDates = () => {
    setEndDate('');
    setDurationStart('');
    setDurationEnd('');
    setPriorEndDate('');
    setPriorDurationStart('');
    setPriorDurationEnd('');
    setOpeningDate('');
    setShowConfirmation(false);
    setDateFieldsDisabled(true);
  };

  useEffect(() => {
    fetchBlobsFromAllContainers();
  }, []);

  const toggleSelection = (container: string, blob: BlobItem) => {
    const exists = selectedBlobs.some(b => b.name === blob.name && b.container === container);
    const newSelection = exists
      ? selectedBlobs.filter(b => !(b.name === blob.name && b.container === container))
      : [...selectedBlobs, { ...blob, container }];
    setSelectedBlobs(newSelection);
    onSelectionChange?.(newSelection);
  };

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>, containerName: string) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);
    formData.append('containerName', containerName);

    try {
      const response = await fetch('/api/app_uploadBlob', { method: 'POST', body: formData });
      const result = await response.json();
      if (response.ok) {
        alert('Upload successful!');
        fetchBlobsFromAllContainers();
      } else {
        alert(`Upload failed: ${result.message || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Upload error:', error);
      alert('Upload failed.');
    }
  };

  const handleDownloadSelected = async (container: string) => {
    const filesToDownload = selectedBlobs.filter(b => b.container === container);
    for (const blob of filesToDownload) {
      try {
        const response = await fetch(`/api/app_downloadBlobs?containerName=${blob.container}&blobName=${encodeURIComponent(blob.name)}`);
        if (!response.ok) throw new Error(`Download failed for ${blob.name}`);
        const blobData = await response.blob();
        const url = window.URL.createObjectURL(blobData);
        const link = document.createElement('a');
        link.href = url;
        link.setAttribute('download', blob.name);
        document.body.appendChild(link);
        link.click();
        link.remove();
      } catch (error) {
        console.error(`Error downloading ${blob.name}:`, error);
        alert(`Error downloading ${blob.name}`);
      }
    }
  };

  const handleEndDateChange = (value: string) => {
    setEndDate(value);
    const selectedDate = dayjs(value);
    if (!selectedDate.isValid()) return;

    let currentStart, priorEnd;
    if (selectedDate.format('DD-MM') === '31-12') {
      currentStart = selectedDate.startOf('year');
      priorEnd = currentStart.subtract(1, 'day');
    } else if (selectedDate.format('DD-MM') === '31-03') {
      currentStart = selectedDate.subtract(1, 'year').add(1, 'day');
      priorEnd = currentStart.subtract(1, 'day');
    } else {
      resetDates();
      return;
    }

    setDurationStart(currentStart.format('YYYY-MM-DD'));
    setDurationEnd(selectedDate.format('YYYY-MM-DD'));
    setPriorEndDate(priorEnd.format('YYYY-MM-DD'));
    setPriorDurationEnd(priorEnd.format('YYYY-MM-DD'));
    const priorStart = currentStart.subtract(1, 'year');
    setPriorDurationStart(priorStart.format('YYYY-MM-DD'));
    setOpeningDate(priorStart.startOf('year').format('YYYY-MM-DD'));
    setShowConfirmation(true);
  };

  return (
    <div style={{ padding: '1rem', border: '1px solid #ddd', borderRadius: '4px' }}>
      <Typography variant="h5" gutterBottom>Blob Viewer</Typography>
      <Box marginBottom={2}>
        <Button variant="contained" color="secondary" onClick={fetchBlobsFromAllContainers} disabled={loading}>
          {loading ? 'Refreshing...' : 'Refresh'}
        </Button>
      </Box>

      <Box display="flex" justifyContent="center" mt={4}>
        <Card variant="outlined" sx={{ padding: 4, width: '650px' }}>
          <Typography variant="h6" gutterBottom>Reporting Period Details</Typography>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={5}><Typography>End Date for Current Period:</Typography></Grid>
            <Grid item xs={7}>
              <TextField type="date" fullWidth size="small" value={endDate} onChange={(e) => handleEndDateChange(e.target.value)} disabled={false} />
            </Grid>
            <Grid item xs={5}><Typography>Duration of Current Period:</Typography></Grid>
            <Grid item xs={3}><TextField type="date" fullWidth size="small" value={durationStart} disabled={dateFieldsDisabled} /></Grid>
            <Grid item xs={1}><Typography textAlign="center">to</Typography></Grid>
            <Grid item xs={3}><TextField type="date" fullWidth size="small" value={durationEnd} disabled={dateFieldsDisabled} /></Grid>
            <Grid item xs={5}><Typography>End Date for Prior Period:</Typography></Grid>
            <Grid item xs={7}><TextField type="date" fullWidth size="small" value={priorEndDate} disabled={dateFieldsDisabled} /></Grid>
            <Grid item xs={5}><Typography>Duration of Prior Period:</Typography></Grid>
            <Grid item xs={3}><TextField type="date" fullWidth size="small" value={priorDurationStart} disabled={dateFieldsDisabled} /></Grid>
            <Grid item xs={1}><Typography textAlign="center">to</Typography></Grid>
            <Grid item xs={3}><TextField type="date" fullWidth size="small" value={priorDurationEnd} disabled={dateFieldsDisabled} /></Grid>
            <Grid item xs={5}><Typography>Opening Date for Prior Period:</Typography></Grid>
            <Grid item xs={7}><TextField type="date" fullWidth size="small" value={openingDate} disabled={dateFieldsDisabled} /></Grid>
          </Grid>

          {showConfirmation && (
            <Box mt={3}>
              <Alert severity="info" action={
                <Stack direction="row" spacing={2}>
                  <Button color="primary" onClick={() => setShowConfirmation(false)}>Dates are OK</Button>
                  <Button color="secondary" onClick={() => setDateFieldsDisabled(false)}>Edit Dates</Button>
                </Stack>
              }>
                The dates have been auto-populated based on your selection. Are these dates correct, or do you wish to edit them manually?
              </Alert>
            </Box>
          )}
        </Card>
      </Box>

      {error && <Typography variant="body1" color="error" gutterBottom>{error}</Typography>}

      {CONTAINER_NAMES.map((containerName) => {
        const blobItems = blobsByContainer[containerName] || [];
        return (
          <Card key={containerName} sx={{ marginBottom: 2 }}>
            <CardContent>
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Typography variant="h6" gutterBottom>Container: {CONTAINER_LABELS[containerName] || containerName}</Typography>
                {containerName === 'silver' && (
                  <>
                    <input
                      type="file"
                      id={`file-input-${containerName}`}
                      style={{ display: 'none' }}
                      onChange={(e) => handleFileUpload(e, containerName)}
                    />
                    <label htmlFor={`file-input-${containerName}`}>
                      <Button variant="outlined" color="primary" size="small" component="span">
                        Upload
                      </Button>
                    </label>
                  </>
                )}
                {containerName === 'gold' && (
                  <Button
                    variant="outlined"
                    color="success"
                    size="small"
                    onClick={() => handleDownloadSelected(containerName)}
                    disabled={selectedBlobs.filter(b => b.container === containerName).length === 0}
                  >
                    Download
                  </Button>
                )}
              </Box>

              {blobItems.length === 0 ? (
                <Typography variant="body2">No files present</Typography>
              ) : (
                <List dense>
                  {blobItems.map((blob) => (
                    <ListItem key={blob.name} disablePadding>
                      <Checkbox
                        checked={selectedBlobs.some(
                          (b) => b.name === blob.name && b.container === containerName
                        )}
                        onChange={() => toggleSelection(containerName, blob)}
                      />
                      <ListItemText
                        primary={<Link href={blob.url} target="_blank" rel="noopener noreferrer">{blob.name}</Link>}
                        primaryTypographyProps={{ align: 'center' }}
                      />
                    </ListItem>
                  ))}
                </List>
              )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
};

export default BlobList;
